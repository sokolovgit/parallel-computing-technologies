> ![](media/image1.png){width="5.8566579177602796in"
> height="1.0166272965879266in"}
>
> Міністерство освіти та науки України
>
> Національний технічний університет України
>
> «Київський політехнічний інститут імені Ігоря Сікорського» Факультет
> інформатики та обчислювальної техніки
>
> Кафедра інформатики і програмної інженерії
>
> **Звіт**
>
> з дисципліни «Технології розподілених обчислень»
>
> Комп'ютерний практикум №2
>
> «Розробка паралельних програм з використанням механізмів синхронізації: синхронізовані методи, локери, спеціальні типи»
>
> **[Виконав:]{.underline}**
>
> *Студент III курсу*
>
> *гр. ІП-33*
>
> ПІБ
>
> **[Прийняв:]{.underline}**
>
> Дифучин А. Ю.
>
> "___" ________ 2026 р.
>
> **Київ -- 2026**

### Комп'ютерний практикум №2

Тема: Розробка паралельних програм з використанням механізмів синхронізації: синхронізовані методи, локери, спеціальні типи.

Мета: Здобути практичні навички використання механізмів синхронізації потоків у Java (синхронізовані методи, локери, спеціальні типи), реалізувати приклад Producer-Consumer, електронний журнал оцінок та кероване виведення символів у потоках.

Завдання:

1. Реалізуйте програмний код, даний у лістингу (AsynchBankTest), та протестуйте його при різних значеннях параметрів. Модифікуйте програму, використовуючи методи управління потоками, так, щоб її робота була завжди коректною. Запропонуйте три різних варіанти управління. 30 балів.

2. Реалізуйте приклад Producer-Consumer application (див. https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html ). Модифікуйте масив даних цієї програми, які читаються, у масив чисел заданого розміру (100, 1000 або 5000) та протестуйте програму. Зробіть висновок про правильність роботи програми. 20 балів.

3. Реалізуйте роботу електронного журналу групи, в якому зберігаються оцінки з однієї дисципліни трьох груп студентів. Кожного тижня лектор і його 3 асистенти виставляють оцінки з дисципліни за 100-бальною шкалою. 20 балів.

4. Створіть три потоки, один з яких виводить на консоль символ '|', другий – символ '\', а третій – символ '/'. Запустіть потоки в основній програмі так, щоб вони виводили свої символи в рядок. Виведіть на консоль 90 таких рядків. Поясніть виведений результат. 10 балів. Використовуючи методи управління потоками, добийтесь почергового виведення на консоль символів так, щоб утворювався рядок |\/|\/|\/… . 15 балів.

5. Зробіть висновки про використання методів управління потоками в Java. 5 балів.

### Виконання

### Завдання 1

За лістингом із завдання було реалізовано консольну програму `AsynchBankTest` (пакет `part_1.bank`), яка моделює банк із `NACCOUNTS = 10` рахунками та початковим балансом `INITIAL_BALANCE = 10000` на кожному рахунку. Для кожного рахунку створюється окремий потік `TransferThread`, який багаторазово (параметр `REPS`) виконує випадкові перекази коштів між рахунками методом `transfer(from, to, amount)`. Після кожних `NTEST = 10000` транзакцій виконується перевірка `test()`, що обчислює суму всіх балансів і виводить у консоль кількість транзакцій та поточну суму.

Було реалізовано чотири варіанти банку: один небезпечний (`UnsafeBank`) та три коректні варіанти керування потоками. У варіанті `UnsafeBank` масив `accounts[]` змінюється без будь-якої синхронізації, тому одночасні операції `accounts[from] -= amount` та `accounts[to] += amount` можуть «перекривати» одна одну, що призводить до втрати оновлень і зміни загальної суми коштів.

![](media/image2.png){width="6.268055555555556in" height="4.013194444444444in"}

**Рисунок 1.1** — [SCREENSHOT: Консольний вивід програми AsynchBankTest у варіанті `UnsafeBank` (без синхронізації) — кілька рядків виду `UnsafeBank -> transactions: ... sum: ...`, де `sum` суттєво відрізняється від очікуваного значення `NACCOUNTS * INITIAL_BALANCE = 100000`. Вставте скріншот як `media/image2.png`.]

При відсутності синхронізації в `UnsafeBank` операції над елементами масиву `accounts` не є атомарними та можуть виконуватися паралельно в різних потоках. Декілька потоків можуть одночасно зчитувати старий баланс, змінювати його та записувати результат, «перетираючи» оновлення один одного. Унаслідок такої гонки потоків (race condition) частина транзакцій втрачається, а сумарний баланс зменшується та стає непередбачуваним — саме це видно у виводі на рисунку 1.1.

![](media/image3.png){width="6.268055555556in" height="3.5in"}

**Рисунок 1.2** — [SCREENSHOT: Консольний вивід варіанту `SynchronizedBank` (синхронізовані методи) — рядки виду `SynchronizedBank -> transactions: ... sum: 100000`, де `sum` завжди дорівнює `NACCOUNTS * INITIAL_BALANCE`. Вставте як `media/image3.png`.]

![](media/image4.png){width="6.268055555556in" height="3.5in"}

**Рисунок 1.3** — [SCREENSHOT: Консольний вивід другого варіанта `LockBank` (ReentrantLock) — рядки `LockBank -> transactions: ... sum: 100000`. Вставте як `media/image4.png`.]

![](media/image5.png){width="6.268055555556in" height="3.5in"}

**Рисунок 1.4** — [SCREENSHOT: Консольний вивід третього варіанту `AtomicBank` (AtomicIntegerArray + AtomicLong) — рядки `AtomicBank -> transactions: ... sum: 100000, expected: 100000`. Вставте як `media/image5.png`.]

У варіанті `SynchronizedBank` коректність досягається завдяки монітору об’єкта: одночасно в межах одного екземпляра банку може виконуватися лише один метод `transfer()` або `test()`, тому операції над масивом `accounts[]` виконуються послідовно без втрати оновлень. У `LockBank` використано явний локер `ReentrantLock`, який дає той самий рівень взаємного виключення, але з більш гнучким керуванням блокуванням. У `AtomicBank` баланси рахунків зберігаються в `AtomicIntegerArray`, а лічильник транзакцій — в `AtomicLong`; разом із глобальним `ReentrantLock` це забезпечує як потокобезпечність оновлень, так і збереження інваріанту суми (sum завжди дорівнює очікуваному значенню). Усі три синхронізовані варіанти гарантують збереження суми, але відрізняються простотою синтаксису та можливостями для розширення (локери й атомарні типи зручніші в складніших сценаріях).

**\**

### Завдання 2

Реалізовано приклад Producer-Consumer за патерном guarded blocks (Oracle tutorial): спільний об’єкт `BoundedBuffer` з методами `put(int)` та `take()`, які використовують `synchronized`, цикл `while (умова) { wait(); }` та `notifyAll()` після зміни стану. Буфер має заданий розмір (100, 1000 або 5000 елементів) і зберігає масив цілих чисел; при повному буфері producer блокується, при порожньому — consumer. Потік `Producer` послідовно записує числа 0, 1, 2, … до заданої кількості; потік `Consumer` читає їх у буфер і зберігає в масив. Після завершення обох потоків виконується перевірка: кількість отриманих значень, їхня сума (має дорівнювати 0+1+…+(n−1)), відсутність дублікатів і наявність усіх чисел з діапазону. Програма `ProducerConsumerDemo` запускає тест для кожного розміру буфера (100, 1000, 5000) і виводить результат перевірки (CORRECT/INCORRECT) та час виконання.

![](media/image6.png){width="6.268055555556in" height="3.5in"}

**Рисунок 2.1** — [SCREENSHOT: Консольний вивід Producer-Consumer для розміру буфера 100 — блок «--- Buffer size: 100 ---», рядки Count/Sum/No duplicates/Result: CORRECT. Вставте як media/image6.png]

![](media/image7.png){width="6.268055555556in" height="3.5in"}

**Рисунок 2.2** — [SCREENSHOT: Тест для розміру 1000 (Buffer size: 1000, Result: CORRECT). Вставте як media/image7.png]

![](media/image8.png){width="6.268055555556in" height="3.5in"}

**Рисунок 2.3** — [SCREENSHOT: Тест для розміру 5000 (Buffer size: 5000, Result: CORRECT). Вставте як media/image8.png]

При усіх трьох розмірах буфера (100, 1000, 5000) програма працює коректно: споживач отримує рівно стільки чисел, скільки виробив виробник, без втрат і дублювань; сума та перевірка діапазону збігаються з очікуваними. Це підтверджує, що використання guarded blocks (wait/notifyAll) та одного монітора для put/take забезпечує правильну взаємодію потоків і збереження даних у обмеженому буфері.

**\**

### Завдання 3

[ОПИС: Опишіть модель даних: три групи, студенти в кожній групі, оцінки з однієї дисципліни за 100-бальною шкалою по тижнях. Як реалізовані потоки: один — лектор, три — асистенти; хто і як виставляє оцінки (наприклад, лектор виставляє базові оцінки за тиждень, асистенти дописують/коригують). Яку синхронізацію використано (synchronized, Lock), щоб уникнути конфліктів при одночасному записі.]

![](media/image9.png){width="6.268055555556in" height="4.0in"}

**Рисунок 3.1** — [SCREENSHOT: Консольний вивід після роботи потоків — фрагмент або повна таблиця оцінок по групах/тижнях (або підсумкова статистика). Вставте як media/image9.png]

[ПОЯСНЕННЯ: Поясніть, як синхронізація гарантує, що оцінки коректно записані всіма чотирма потоками без втрати оновлень.]

**\**

### Завдання 4

[ОПИС: Опишіть реалізацію трьох потоків, які виводять символи '|', '\', '/' відповідно. Спочатку — версія без координації: потоки просто виводять свої символи в рядок; отриманий вивід неупорядкований. Потім — версія з методами управління потоками (wait/notify або Lock/Condition, або семафори), щоб досягти черговості та отримати рядок виду |\/|\/|\/… .]

![](media/image10.png){width="6.268055555556in" height="4.0in"}

**Рисунок 4.1** — [SCREENSHOT: Консольний вивід 90 рядків без синхронізації — видно випадкове чергування символів |, \, /. Вставте як media/image10.png]

[ПОЯСНЕННЯ: Поясніть виведений результат: чому порядок символів непередбачуваний (потоки виконуються паралельно, планувальник перемикає їх у довільному порядку).]

![](media/image11.png){width="6.268055555556in" height="4.0in"}

**Рисунок 4.2** — [SCREENSHOT: Консольний вивід 90 рядків із синхронізацією — кожен рядок має вигляд |\/|\/|\/… (або кілька повторень цього патерну в рядку). Вставте як media/image11.png]

[ПОЯСНЕННЯ: Поясніть, як методи управління потоками (які саме використані) забезпечують почергове виведення символів у потрібному порядку.]

**\**

### Завдання 5

[ВИСНОВКИ: Коротко сформулюйте висновки про використання методів управління потоками в Java на основі виконаних завдань: синхронізовані методи та блоки, ReentrantLock, wait/notify (guarded methods), умовні змінні (Condition), атомарні типи. Коли який підхід зручніший; переваги та обмеження.]

**\**

### Висновок

[ОПИС: Узагальнюючий висновок по практикуму №2: що реалізовано в частинах 1–4, які механізми синхронізації використані, які висновки зроблено щодо коректності та порівняння варіантів управління потоками. 2–4 абзаци.]

**\**

**Код програми**

Посилання на GitHub репозиторій:
https://github.com/sokolovgit/parallel-computing-technologies

**Задача 1**

[Вставте лістинг основних класів: AsynchBankTest.java, Bank.java (або варіанти Bank з різними способами синхронізації), TransferThread.java. Можна окремо позначити варіанти, наприклад BankSynchronized, BankWithLock, BankAtomic.]

**Задача 2**

Лістинги класів у пакеті `part_2.producerconsumer`: `BoundedBuffer.java` (put/take з wait/notifyAll), `Producer.java`, `Consumer.java`, `ProducerConsumerDemo.java` (тести для розмірів буфера 100, 1000, 5000).

**Задача 3**

[Вставте лістинг класів електронного журналу: модель даних (Gradebook, Group, Student), потоки Lecturer, Assistant, main.]

**Задача 4**

[Вставте лістинг потоків виведення символів: версія без синхронізації та версія з синхронізацією для патерну |\/|\/|\/… .]
