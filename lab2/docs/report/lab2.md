> ![](media/image1.png){width="5.8566579177602796in"
> height="1.0166272965879266in"}
>
> Міністерство освіти та науки України
>
> Національний технічний університет України
>
> «Київський політехнічний інститут імені Ігоря Сікорського» Факультет
> інформатики та обчислювальної техніки
>
> Кафедра інформатики і програмної інженерії
>
> **Звіт**
>
> з дисципліни «Технології розподілених обчислень»
>
> Комп'ютерний практикум №2
>
> «Розробка паралельних програм з використанням механізмів синхронізації: синхронізовані методи, локери, спеціальні типи»
>
> **[Виконав:]{.underline}**
>
> *Студент III курсу*
>
> *гр. ІП-33*
>
> ПІБ
>
> **[Прийняв:]{.underline}**
>
> Дифучин А. Ю.
>
> "___" ________ 2026 р.
>
> **Київ -- 2026**

### Комп'ютерний практикум №2

Тема: Розробка паралельних програм з використанням механізмів синхронізації: синхронізовані методи, локери, спеціальні типи.

Мета: Здобути практичні навички використання механізмів синхронізації потоків у Java (синхронізовані методи, локери, спеціальні типи), реалізувати приклад Producer-Consumer, електронний журнал оцінок та кероване виведення символів у потоках.

Завдання:

1. Реалізуйте програмний код, даний у лістингу (AsynchBankTest), та протестуйте його при різних значеннях параметрів. Модифікуйте програму, використовуючи методи управління потоками, так, щоб її робота була завжди коректною. Запропонуйте три різних варіанти управління. 30 балів.

2. Реалізуйте приклад Producer-Consumer application (див. https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html ). Модифікуйте масив даних цієї програми, які читаються, у масив чисел заданого розміру (100, 1000 або 5000) та протестуйте програму. Зробіть висновок про правильність роботи програми. 20 балів.

3. Реалізуйте роботу електронного журналу групи, в якому зберігаються оцінки з однієї дисципліни трьох груп студентів. Кожного тижня лектор і його 3 асистенти виставляють оцінки з дисципліни за 100-бальною шкалою. 20 балів.

4. Створіть три потоки, один з яких виводить на консоль символ '|', другий – символ '\', а третій – символ '/'. Запустіть потоки в основній програмі так, щоб вони виводили свої символи в рядок. Виведіть на консоль 90 таких рядків. Поясніть виведений результат. 10 балів. Використовуючи методи управління потоками, добийтесь почергового виведення на консоль символів так, щоб утворювався рядок |\/|\/|\/… . 15 балів.

5. Зробіть висновки про використання методів управління потоками в Java. 5 балів.

### Виконання

### Завдання 1

За лістингом із завдання було реалізовано консольну програму `AsynchBankTest` (пакет `part_1.bank`), яка моделює банк із `NACCOUNTS = 10` рахунками та початковим балансом `INITIAL_BALANCE = 10000` на кожному рахунку. Для кожного рахунку створюється окремий потік `TransferThread`, який багаторазово (параметр `REPS`) виконує випадкові перекази коштів між рахунками методом `transfer(from, to, amount)`. Після кожних `NTEST = 10000` транзакцій виконується перевірка `test()`, що обчислює суму всіх балансів і виводить у консоль кількість транзакцій та поточну суму.

Було реалізовано чотири варіанти банку: один небезпечний (`UnsafeBank`) та три коректні варіанти керування потоками. У варіанті `UnsafeBank` масив `accounts[]` змінюється без будь-якої синхронізації, тому одночасні операції `accounts[from] -= amount` та `accounts[to] += amount` можуть «перекривати» одна одну, що призводить до втрати оновлень і зміни загальної суми коштів.

![](media/image2.png){width="6.268055555555556in" height="4.013194444444444in"}

**Рисунок 1.1** — [SCREENSHOT: Консольний вивід програми AsynchBankTest у варіанті `UnsafeBank` (без синхронізації) — кілька рядків виду `UnsafeBank -> transactions: ... sum: ...`, де `sum` суттєво відрізняється від очікуваного значення `NACCOUNTS * INITIAL_BALANCE = 100000`. Вставте скріншот як `media/image2.png`.]

При відсутності синхронізації в `UnsafeBank` операції над елементами масиву `accounts` не є атомарними та можуть виконуватися паралельно в різних потоках. Декілька потоків можуть одночасно зчитувати старий баланс, змінювати його та записувати результат, «перетираючи» оновлення один одного. Унаслідок такої гонки потоків (race condition) частина транзакцій втрачається, а сумарний баланс зменшується та стає непередбачуваним — саме це видно у виводі на рисунку 1.1.

![](media/image3.png){width="6.268055555556in" height="3.5in"}

**Рисунок 1.2** — [SCREENSHOT: Консольний вивід варіанту `SynchronizedBank` (синхронізовані методи) — рядки виду `SynchronizedBank -> transactions: ... sum: 100000`, де `sum` завжди дорівнює `NACCOUNTS * INITIAL_BALANCE`. Вставте як `media/image3.png`.]

![](media/image4.png){width="6.268055555556in" height="3.5in"}

**Рисунок 1.3** — [SCREENSHOT: Консольний вивід другого варіанта `LockBank` (ReentrantLock) — рядки `LockBank -> transactions: ... sum: 100000`. Вставте як `media/image4.png`.]

![](media/image5.png){width="6.268055555556in" height="3.5in"}

**Рисунок 1.4** — [SCREENSHOT: Консольний вивід третього варіанту `AtomicBank` (AtomicIntegerArray + AtomicLong) — рядки `AtomicBank -> transactions: ... sum: 100000, expected: 100000`. Вставте як `media/image5.png`.]

У варіанті `SynchronizedBank` коректність досягається завдяки монітору об’єкта: одночасно в межах одного екземпляра банку може виконуватися лише один метод `transfer()` або `test()`, тому операції над масивом `accounts[]` виконуються послідовно без втрати оновлень. У `LockBank` використано явний локер `ReentrantLock`, який дає той самий рівень взаємного виключення, але з більш гнучким керуванням блокуванням. У `AtomicBank` баланси рахунків зберігаються в `AtomicIntegerArray`, а лічильник транзакцій — в `AtomicLong`; разом із глобальним `ReentrantLock` це забезпечує як потокобезпечність оновлень, так і збереження інваріанту суми (sum завжди дорівнює очікуваному значенню). Усі три синхронізовані варіанти гарантують збереження суми, але відрізняються простотою синтаксису та можливостями для розширення (локери й атомарні типи зручніші в складніших сценаріях).

**\**

### Завдання 2

Реалізовано приклад Producer-Consumer за патерном guarded blocks (Oracle tutorial): спільний об’єкт `BoundedBuffer` з методами `put(int)` та `take()`, які використовують `synchronized`, цикл `while (умова) { wait(); }` та `notifyAll()` після зміни стану. Буфер має заданий розмір (100, 1000 або 5000 елементів) і зберігає масив цілих чисел; при повному буфері producer блокується, при порожньому — consumer. Потік `Producer` послідовно записує числа 0, 1, 2, … до заданої кількості; потік `Consumer` читає їх у буфер і зберігає в масив. Після завершення обох потоків виконується перевірка: кількість отриманих значень, їхня сума (має дорівнювати 0+1+…+(n−1)), відсутність дублікатів і наявність усіх чисел з діапазону. Програма `ProducerConsumerDemo` запускає тест для кожного розміру буфера (100, 1000, 5000) і виводить результат перевірки (CORRECT/INCORRECT) та час виконання.

![](media/image6.png){width="6.268055555556in" height="3.5in"}

**Рисунок 2.1** — [SCREENSHOT: Консольний вивід Producer-Consumer для розміру буфера 100 — блок «--- Buffer size: 100 ---», рядки Count/Sum/No duplicates/Result: CORRECT. Вставте як media/image6.png]

![](media/image7.png){width="6.268055555556in" height="3.5in"}

**Рисунок 2.2** — [SCREENSHOT: Тест для розміру 1000 (Buffer size: 1000, Result: CORRECT). Вставте як media/image7.png]

![](media/image8.png){width="6.268055555556in" height="3.5in"}

**Рисунок 2.3** — [SCREENSHOT: Тест для розміру 5000 (Buffer size: 5000, Result: CORRECT). Вставте як media/image8.png]

При усіх трьох розмірах буфера (100, 1000, 5000) програма працює коректно: споживач отримує рівно стільки чисел, скільки виробив виробник, без втрат і дублювань; сума та перевірка діапазону збігаються з очікуваними. Це підтверджує, що використання guarded blocks (wait/notifyAll) та одного монітора для put/take забезпечує правильну взаємодію потоків і збереження даних у обмеженому буфері.

**\**

### Завдання 3

Реалізовано електронний журнал у пакеті `part_3.gradebook`. Модель даних: три групи, у кожній по `studentsPerGroup` студентів (у демо — 5), оцінки з однієї дисципліни за 100-бальною шкалою за кожен із `weeksCount` тижнів (у демо — 4). Дані зберігаються в масиві `grades[група][студент][тиждень]`. Один потік — лектор (`LecturerThread`): кожного тижня виставляє оцінку кожному студенту в усіх трьох групах (діапазон 60–100). Три потоки — асистенти (`AssistantThread`): асистент i виставляє оцінки лише студентам групи i за всі тижні (50–100). Усі чотири потоки працюють одночасно; для однієї комірки (група, студент, тиждень) останній запис «перекриває» попередній. Синхронізація: у класі `Gradebook` методи `setGrade` та `getGrade` (і формування таблиці) використовують один `ReentrantLock` — кожен запис і читання виконуються під замком, тому немає втрати оновлень і читання бачить узгоджений стан.

![](media/image9.png){width="6.268055555556in" height="4.0in"}

**Рисунок 3.1** — [SCREENSHOT: Консольний вивід після завершення потоків — заголовок «Electronic gradebook…» та повна таблиця оцінок по групах (Group 1–3), студентах і тижнях з середніми. Вставте як media/image9.png]

Синхронізація через один загальний замок (`ReentrantLock`) гарантує, що в момент запису оцінки в комірку жоден інший потік не читає й не змінює цю комірку одночасно. Усі оновлення від лектора та асистентів послідовні з точки зору доступу до спільного стану журналу, тому не виникає гонок і втрачених записів; після join усіх потоків таблиця містить коректні остаточні значення.

**\**

### Завдання 4

Реалізовано програму, в якій три потоки виводять символи '|', '\', '/' відповідно. Виведено задану кількість рядків по заданій кількості символів у рядку. Дві версії:

**Частина 1 — без координації:** Кожен потік у циклі виводить свій символ. Синхронізація використовується лише для спільного підрахунку символів та виводу переведення рядка після кожних N символів; порядок виводу символів між потоками не узгоджується. Потоки виконуються паралельно, планувальник вирішує, хто виконується в даний момент, тому послідовність символів у рядку непередбачувана (хаотичне чергування |, \, /).

**Частина 2 — почерговий вивід |\/|\/|\/...:** Використано один спільний замок і змінну стану (черга). Кожен потік під замком чекає, поки не настане його черга (за умовою в циклі while і викликом wait), виводить один символ, оновлює стан і сповіщає інші потоки (notifyAll). Після кожних N символів виводиться переведення рядка. Таким чином досягається суворий порядок: спочатку |, потім \, потім /, знову |, \, / тощо — у кожному рядку повторюється патерн |\/|\/|\/... .

![](media/image10.png){width="6.268055555556in" height="4.0in"}

**Рисунок 4.1** — Консольний вивід без координації: задана кількість рядків по N символів, випадкове чергування |, \, /. Вставте скріншот як media/image10.png.

Порядок символів без координації непередбачуваний: потоки виконуються паралельно, планувальник надає їм кванту часу в довільному порядку, вивід у консоль не синхронізований між потоками, тому символи змішуються випадково.

![](media/image11.png){width="6.268055555556in" height="4.0in"}

**Рисунок 4.2** — Консольний вивід із координацією (wait/notify): кожен рядок має вигляд |\/|\/|\/... Вставте скріншот як media/image11.png.

Методи wait() та notifyAll() у поєднанні з перевіркою умови в циклі while забезпечують жорстку черговість: лише один потік за раз виводить символ, і лише коли настала його черга. Після виводу черга переходить до наступного потоку, тому виходить патерн |\/|\/|\/… .

**\**

### Завдання 5

**Висновки про методи управління потоками в Java**

Синхронізовані методи та блоки — найпростіший варіант: один потік за раз виконує захищений код, монітор прив'язаний до об'єкта. Коду мало, логіка зрозуміла. Чекати на умову (на кшталт «поки буфер не порожній») або ставити таймаут так не вийде.

**Синхронізовані методи та блоки (synchronized):** найпростіший спосіб забезпечити взаємне виключення — помітити метод як synchronized або використати блок synchronized(об'єкт). Монітор прив’язаний до об’єкта; один потік за раз може виконувати синхронізований код для цього об’єкта. Переваги: мінімум коду, зрозумілість. Обмеження: не можна умовно чекати (наприклад, «поки буфер не порожній»), важко комбінувати кілька умов або використовувати таймаути.

Явний замок ReentrantLock дає те саме взаємне виключення, але з більшими можливостями: можна брати замок з таймаутом, використовувати умовні черги (Condition). Треба лише пам'ятати викликати unlock(), краще в finally.

Коли потрібно саме очікування умови — використовують wait() і notify() (або notifyAll()) разом із synchronized. Потік захоплює монітор, у циклі while перевіряє умову і при потребі викликає wait(); інший потік, змінивши стан, викликає notifyAll(). Так зроблено в producer-consumer (буфер) і в задачі з черговістю символів. Умову обов'язково перевіряти в циклі while, щоб після пробудження переконатися, що вона справді виконалась.

Атомарні типи (AtomicInteger тощо) дозволяють робити одиничні операції без замку — зручно для лічильників і простих оновлень. Якщо ж потрібно узгоджувати кілька змінних (зняти з одного рахунку і додати на інший), одного атомарного типу замало, потрібен замок або інший механізм.

У роботі: у завданні 1 використано synchronized і ReentrantLock (і варіант з атомарними типами), у завданнях 2 і 4 — wait/notify. Для простого захисту ділянки коду достатньо synchronized; коли потрібно чекати на умову — wait/notify; коли потрібні таймаути або складніші умови — ReentrantLock і Condition.

**\**

### Висновок

У межах комп’ютерного практикуму №2 отримано практичні навички використання механізмів синхронізації потоків у Java та реалізовано чотири частини завдань.

У частині 1 реалізовано модель банку з багатьма потоками переказів; продемонстровано, що без синхронізації виникає гонка і сума по рахунках перестає збігатися з очікуваною. Запропоновано три коректні варіанти: синхронізовані методи, явний замок ReentrantLock та використання атомарних типів у поєднанні з замком — усі вони зберігають інваріант суми. У частині 2 реалізовано приклад producer-consumer з обмеженим буфером цілих чисел та патерном guarded blocks (wait/notifyAll); перевірено коректність при різних розмірах буфера. У частині 3 реалізовано електронний журнал оцінок: три групи, лектор і три асистенти виставляють оцінки паралельно; один ReentrantLock забезпечує узгодженість записів. У частині 4 реалізовано три потоки, що виводять символи |, \, /: спочатку без координації (хаотичний вивід), потім з координацією через wait/notify для отримання патерну |\/|\/|\/… .

Підсумовуючи, виконані завдання охоплюють синхронізовані методи та блоки, явні замки (ReentrantLock), методи wait/notify для умовного очікування та атомарні типи. Кожен підхід має свою область застосування; правильний вибір механізму синхронізації забезпечує коректність і передбачуваність багатопотокових програм.

**\**

**Код програми**

Посилання на GitHub репозиторій:
https://github.com/sokolovgit/parallel-computing-technologies

**Задача 1**

[Вставте лістинг основних класів: AsynchBankTest.java, Bank.java (або варіанти Bank з різними способами синхронізації), TransferThread.java. Можна окремо позначити варіанти, наприклад BankSynchronized, BankWithLock, BankAtomic.]

**Задача 2**

Лістинги класів у пакеті `part_2.producerconsumer`: `BoundedBuffer.java` (put/take з wait/notifyAll), `Producer.java`, `Consumer.java`, `ProducerConsumerDemo.java` (тести для розмірів буфера 100, 1000, 5000).

**Задача 3**

Лістинги класів у пакеті `part_3.gradebook`: `Gradebook.java` (модель даних, ReentrantLock для setGrade/getGrade та formatTable), `LecturerThread.java`, `AssistantThread.java`, `GradebookDemo.java` (запуск лектора та трьох асистентів, вивід таблиці).

**Задача 4**

Лістинг у пакеті part_4.printers: один клас з двома варіантами потоків (без координації та з координацією через wait/notify для патерну |\/|\/|\/…).
